### AoC 2021 Postmortems

# Day One

- Remember to save input as text file
- Initializing an `Int` from a string returns optional
- The `lines` library function would have worked well modulo the above
- Actual text editing in BBEdit much more awkward than using vim
  * AI: review Cocoa text editing keybindings
- Got all the comparators wrong the first time, but that's normal

Video:
- Uploading screen recording is *slow*, so kick it off that night
- "Natural" text sizes on my 27" QHD display are unreadable on YouTube
  * AI: Use comically large fonts for "interesting" windows
- Voice is nasal and whiny

# Day Two

- Marshal input in one place
- Really hard to move quickly *and* make a video
  - Nerves when doing things publicly are a thing
  - Talking while coding is a balance...or a skill
- Keep the camera window visible

# Day Three

- We've already reached the point where a minute's thought may be better than a minute's typing
- `[Int](repeating: 0, count: 12)` was the better way to build the array
- Worth knowing `[Int:Int](uniqueKeysWithValues: (0..<12).map { ($0, 0) })` as well
- Get the code working *before* cut-and-paste reuse
- Would a function with a "reverse" parameter really have been better than cut-and-paste reuse
  - Main upside would be documenting clear(er) semantics
- Think through boundary conditions when reading problem

- Half-hour video is 10 gigs: 13 hours(!) to upload to YouTube
  * AI: encode locally at...720p?...before uploading
  * AI: Store originals on external media that isn't iCloud synced


# Day Four

- I find the default for `String.split` `omittingEmptySubsequences` unintuitive.
- an any-whitespace-based `split` would be useful
- could have parsed bingo card numbers by *position*, not by splitting
- Parsing the input took 20 minutes!
- There was a bug; how was our debugging strategy?
  - Not terrible! Immediately had a handful of theories. Ruled them out.
  - But delayed revisiting the correct theory because it seemed hard to test!
  - We *were* logging the data we needed to spot the bug: the column number was always zero!
    - Should have spotted this at 41' (at least)
  - At 36' you can see me taking a minute thinking "it's been a stressful day. maybe give up and try it in the morning"
  - A lot of debugging is just dealing with your own frustration
- This is why we do this! Debugging novel code is good experience.
- In spite of the bug, I genuinely enjoyed this puzzle.
- My approach was to check every board after every number
  - O(numbers called * number of boards * (rows * rowsize + cols * colsize))
  - What if there had been LOTS of numbers called and/or LOTS of boards
    - Dict from number called to the rows/cols it's in
      - and a pointer from that row/col to the boards it's in
      - class Board { [[Int]] }
      - [Int:([Int], Board)]
      - or store, not the board, but a scoring function: (Set<Int>)->Int
  - What if the board sizes were enormous?
    - hard to imagine, but [Int:(Set<Int>, Board)]
    - *much* slower for 5x5 boards

- 480p is too low quality; it leaves text very fuzzy

# Day Five

- Tuples are still not first class in Swift (not hashable, among other things)
- parsing only took five minutes this time
- `Set.insert` returns `(inserted: Bool, memberAfterInsert: Element)`
- Really should pair "start" with "finish" and "begin" with "end"
- After a couple of wrong attempts, think before submitting answers
- "If you have (1, 1) and (3, 3), you subtract them and get 2, so (the `i`s) are 0, 1, and 2"
  - But that's exactly what's wrong: you *don't* get 2.
- The visualization didn't help...but I still like it as a sanity check
- Could have used line and char numbers (which BBEdit displays) to check against input data
- Could have pulled out diagonal code and checked that it explored the right points for a test input
  - This is closer to how you'd unit test "real" code
- Debugging "strategy" was worse than Day Four
- Took *forever* to even bother hand-simulating the broken five lines of code

- 720p is *just* high enough quality. But probably should upload 1080p.

- AoC does wear me down. Particularly bad days.

# Day Six

- A lot of dithering over running the Part 1 code for Part 2...when I knew it wouldn't work
- Remember that dictionary lookups return optionals
- Used loops instead of one-liners in several places...
  - ...and that's probably okay if the one-liners aren't in your fingers.
  - ...but kinda embarrassing.
- Poor job explaining the strategy

# Day Seven

- I still don't know if Swift has an "average" function...but `reduce` is a rudiment
  - compute a total with `.reduce(0, +)`
- The actual position is the *median* for the first part, and the mean for pt 2
  - My analytical proof of this is surely over-complex...and not worth doing
  - Getting comfortable with using computers instead of analyzing was a thing for me
    - props to 538's "Riddler" puzzles (which I did every week for a while)
- `min` and `max` (among many others) are *member* functions in Swift
  - I'm still gaining intuition about how extensions change API design
- sixteen minus five is eleven, not nine
- the average of the numbers from 1 to 100 is 50.5, not 50
- check personal stats
- one-liner versions

# Day Eight

- READ. THE. PROBLEM.
- But the problem I solved was also fun!

- Apple's screen recorder is not bullet proof.
  - Was it because the recording was over an hour?
* AI: Switch to OBS
  - Try live-streaming
  
# Day Nine

- I'm much more easily flustered by *trivial* code...
- Is there an "elegant" code structure for neighbor coordinates?
- We didn't realize that we were doing `Character` comparison instead of `Int` comparison...but they're equivalent for single digits
- Marshal input early!
- `while let cur = q.pop()` is a beautiful code structure
- Forgot to insert the low point into the basin on the first pass
- `if s.insert(e).inserted { ... }` is the idiom...
  - ...but beware short circuits!
    - `if someCondition && s.insert(e).inserted { ... }`
- Why did I make `Queue` a class? Because I didn't implement deep copy!

# Day Ten

- Never got to talking about `Queue` class vs struct
- Think through your code structure before typing to be fast
- "explore to figure out what bits of logic you need, then plumb together" pretty consistently produces ugly code. But it's a way to find the crux!
- There *are* (fairly) elegant code structures for parsing
  - You need to do a few of them for them to feel natural
- Could have used the `closes` dictionary to identify open delimiters
- "Remember to increment pos" is a thing from experience
- Recursive (and all nontrivial parsing) on untrusted input
  - JSON and YAML are awesome
- READ THE PROBLEM. (Even part 2.)
- `if let a = b && XXX` can't use `a` in `XXX`
  - `if let a = b, XXX` can.
- lldb and DYLD_LIBRARY_PATH environment variable
  - `process launch -v DYLD_LIBRARY_PATH=foo`

- New recording setup seems to work
  - Ending live stream kills buffer (cuts off last 20 seconds)
- How do I replace low-quality live stream with high-quality recording?


# Day Eleven

- Again, most of the time wasted writing a trivial `neighbors` function
- Maybe grids of numbers are a thing this year? So, add library utilities.
- Of course once everything is synced it will repeat every ten steps
- And of course everything will synchronize in only a few hundred steps

- live stream didn't work
  - the OBS interface is open-source quality


# Day Twelve

- Again, all the (minor) issues were not paying sufficient attention to problem description
  - graph structure is bidirectional
  - use of 'start' (in both parts)
- never actually used `rooms`
- What's the difference between `x[y] ?? z` and `x[y, default: z]`?

# Day Thirteen

- The parsing. Oh gods the parsing.
  - Everybody gets flustered. And, again, it's often on *easy* stuff.
  - Don't be afraid to preprocess by hand! This code will be run *once*!!!
  - No subscript by integer range (even in my library); called `slice`
  - "Record"-based parsing requires `omittingEmptySubsequences: false`
- Just a generally bad day for the brain grokking code structure
  - working from the "hard" logic *out* seemed to get me going

# Day Fourteen

- Making the input homogenous by hand was a huge win
- I *had* the print statement to debug my `pair` computation...but didn't run it
- The (/any) algorithm for part 2 was not immediately obvious
  - spend 3 1/2 minutes scanning for patterns, which went nowhere
  - 2 additional mins to find the core of the strategy that did work
- "I can't think with something rattling nearby" is *very* programmer-y
- Writing nontrivial logic is fun!
- lldb hangs backtracing blown stacks!
  - but I did immediately guess that was the problem...because debuggers, man
- Still haven't look at others' solutions
- I really enjoyed this problem. (It shows.)

# Day Fifteen

- Knowing *a* solution can be a huge hindrance in finding nearby solutions
- Reflect on "powerful" algorithm you're going to implement before implementing
  - I *knew* these things needed priority queues. And pqueues are hard to write!
  - I do implement a lot of things from wikipedia (or CLRS)...but doing it "on the clock" I wasn't *thinking*
  - Mistakes are more common when you're not engaged. I hated my approach.
  - Also true for debugging: a lot of debugging is finding excuses not to think
- A better way to "brute force" would have been to write something with a FibHeap API but worse complexities on each operation
  - Lots of interesting ways to make that "good enough!"
  - Array from weights/path length to nodes (size 500)
    - Hybrid with min/max occupied would probably have scaled well: the "active fringe" has very similar values! Range of ten!
- Huge mental block around "Fibonacci Heaps should not be necessary!!!"
- One implementation wasn't "slow"; it was hung. It would have finished modulo the bug.

- Second attempt adds nodes to make every edge weight 1
- Only ten minutes! (And that's while explaining.)
- Making the larger grid "virtual" was quick, but ten minutes debugging fiddly details

- The simple approach was *MUCH* faster, in every way!

# Day Sixteen

- *Much* better global ranking than prior days (?)
- Slow off the mark saving input
- Not a very systematic approach to reading the problem
- Functions taking strings as parameters should be generic on a StringProtocol
- We got answer to part 1—and debug statements showing that is was right—but didn't read them!
- See how much faster I go when I don't talk?

